¬°Perfecto!
Aqu√≠ tienes un instructivo extremadamente detallado, con razonamiento completo, paso a paso, y scripts pr√°cticos, para que puedas convertir todos tus cat√°logos de catalogmx en un √∫nico archivo SQLite unificado, actualizado mensualmente, y servido v√≠a serverless HTTP/Range desde GitHub Pages (o cualquier CDN).

Este instructivo te permitir√°:
	‚Ä¢	entender por qu√© lo hacemos,
	‚Ä¢	replicarlo en tu entorno de desarrollo,
	‚Ä¢	integrarlo con GitHub Actions,
	‚Ä¢	obtener un archivo mexico.sqlite3 listo para usar con SQLite WASM.

‚∏ª

üìò INSTRUCTIVO COMPLETO

Unificar todos los cat√°logos de CatalogMX en un solo SQLite para Serverless Search

‚∏ª

üß† 1. Razonamiento t√©cnico

‚úî Problema actual
	‚Ä¢	Tienes m√∫ltiples archivos SQLite independientes.
	‚Ä¢	Cada archivo contiene un cat√°logo diferente.
	‚Ä¢	Para consultas desde navegador, Node.js o mobile, tendr√≠as que abrir varios archivos.
	‚Ä¢	Cada archivo implica:
	‚Ä¢	un header SQLite,
	‚Ä¢	un B-Tree ra√≠z,
	‚Ä¢	varios bloques,
	‚Ä¢	m√∫ltiples HTTP Range requests.

‚úî Qu√© queremos lograr
	‚Ä¢	Un solo archivo SQLite:
	‚Ä¢	m√°s f√°cil de consumir,
	‚Ä¢	m√°s r√°pido por HTTP,
	‚Ä¢	mejor cacheado,
	‚Ä¢	m√°s portable,
	‚Ä¢	con todas las tablas dentro del mismo contenedor.

‚úî Por qu√© SQLite es perfecto para esto

SQLite fue dise√±ado para:
	‚Ä¢	ser port√°til (un archivo),
	‚Ä¢	ser consultado en modo s√≥lo lectura,
	‚Ä¢	soportar miles de tablas,
	‚Ä¢	permitir schemas independientes entre tablas,
	‚Ä¢	permitir lectura por p√°ginas fijas (~4 KB).

Y con HTTP VFS, el cliente solo descarga:
	‚Ä¢	las p√°ginas del √≠ndice que necesita,
	‚Ä¢	las p√°ginas de los datos que coinciden con la query.

Esto permite serverless search real.

‚∏ª

üß© 2. Dise√±o final del archivo unificado

El archivo se llamar√°:

mexico.sqlite3

Dentro contendr√° tablas como:

cp
asentamientos
colonias
municipios
bancos
claves_sat
productos_sat
impuestos_sat
‚Ä¶

Cada tabla es independiente.
No hay joins obligatorios entre ellas.
Cada una mantiene su propio esquema.

‚∏ª

üîß 3. Requisitos en tu entorno de desarrollo

Necesitar√°s:

A. Python 3.8+

Con sqlite3 incluido por defecto.

B. Tu repositorio clonado

git clone https://github.com/OpenBancor/catalogmx
cd catalogmx

C. Las fuentes:
	‚Ä¢	Los CSVs
	‚Ä¢	Los SQLite originales (si decides no usar los CSV)

D. Revisi√≥n del schema de cada cat√°logo

Esto ya viene de tus archivos existentes.

‚∏ª

üõ†Ô∏è 4. Script: Generar archivo unificado desde cero

Ya existe un generador listo para usarse en:

```
packages/shared-data/build_unified_sqlite.py
```

Caracter√≠sticas principales:
* Fusiona autom√°ticamente los cat√°logos grandes que ya est√°n en `packages/shared-data/sqlite/` (SEPOMEX, INEGI localidades, SAT clave producto/servicio).
* Recorre todo `packages/shared-data/**.json` (Banxico, SAT, IFT, etc.) y crea una tabla por archivo conservando los campos originales.
* A√±ade √≠ndices √∫tiles (`codigos_postales`, `localidades`, `clave_prod_serv`) y genera tablas FTS5 listas para b√∫squedas de texto.
* Soporta banderas para controlar la salida:
  - `--output /ruta/al/archivo.sqlite3`
  - `--skip-json` o `--skip-sqlite` si quieres procesar s√≥lo una fuente.

Uso recomendado (desde la ra√≠z del repo):

```bash
cd packages/shared-data
python build_unified_sqlite.py
# genera packages/shared-data/mexico.sqlite3
```

Si prefieres dejar todo automatizado desde el webapp, usa (desde la ra√≠z del repo):

```bash
cd packages/webapp
npm run data:build
```

Importante: el comando se ejecuta dentro de `packages/webapp`, no en la ra√≠z del repo (de lo contrario `npm` no encontrar√° el `package.json`). Ese script:
1. Ejecuta `build_unified_sqlite.py` (puedes forzar el int√©rprete con `PYTHON=...`).
2. Copia todos los `.db/.sqlite/.sqlite3` resultantes (incluyendo `mexico.sqlite3`) hacia `packages/webapp/public/data/`.

Para copiar √∫nicamente los archivos ya existentes (sin regenerar), sigue usando `npm run sync:data`.


‚∏ª

‚öôÔ∏è 5. Crear √≠ndices apropiados por cat√°logo

Despu√©s de importar todas las tablas, a√±ade esto en el script:

def create_indexes(conn):
    indexes = [
        "CREATE INDEX idx_cp_cp ON cp(cp);",
        "CREATE INDEX idx_cp_estado ON cp(estado);",
        "CREATE INDEX idx_asen_nombre ON asentamientos(nombre);",
        "CREATE INDEX idx_bancos_banco ON bancos(clave);",
        # agrega m√°s √≠ndices seg√∫n necesidad
    ]

    for idx in indexes:
        try:
            conn.execute(idx)
        except:
            print("No se pudo crear √≠ndice:", idx)

    conn.commit()

Luego ll√°malo:

create_indexes(conn)


‚∏ª

üîç 6. Opcional: FTS5 por cat√°logo

Ejemplo para cat√°logo textual:

conn.execute("""
CREATE VIRTUAL TABLE cp_fts USING fts5(
    cp,
    asentamiento,
    municipio,
    estado,
    content='cp'
);
""")

conn.execute("""
INSERT INTO cp_fts(rowid, cp, asentamiento, municipio, estado)
SELECT rowid, cp, asentamiento, municipio, estado FROM cp;
""")

Esto permite b√∫squeda tipo Google:

SELECT * FROM cp_fts WHERE cp_fts MATCH 'santa';


‚∏ª

üöÄ 7. Ejecutar el script

Desde tu repo:

python3 build_unified_sqlite.py

Obtendr√°s:

mexico.sqlite3


‚∏ª

üåê 8. Publicarlo en GitHub Pages

1. Habilita GitHub Pages en branch gh-pages

/docs/
    mexico.sqlite3
    index.html

O estructura:

/gh-pages/
    mexico.sqlite3

2. Haz push del archivo

mkdir docs
cp mexico.sqlite3 docs/
git add docs/mexico.sqlite3
git commit -m "A√±adir archivo SQLite unificado"
git push

Tu base quedar√° accesible v√≠a:

https://openbancor.github.io/catalogmx/mexico.sqlite3


‚∏ª

üñ•Ô∏è 9. Uso desde navegador (SQLite WASM)

Ejemplo minimal:

<script type="module">
import sqlite3InitModule from "https://unpkg.com/@sqlite.org/sqlite-wasm/dist/sqlite-wasm/jswasm/sqlite3.mjs";

const sqlite3 = await sqlite3InitModule();
const db = new sqlite3.oo1.DB(
  "https://openbancor.github.io/catalogmx/mexico.sqlite3",
  "opfs-http"
);

let r = db.exec("SELECT * FROM cp WHERE cp LIKE '03%';");
console.log(r);
</script>

Y con esto, SQLite solo descargar√° 20‚Äì80 KB, no 40 MB.

‚∏ª

üîÅ 10. Actualizaciones mensuales

Cada mes:

git pull
python3 build_unified_sqlite.py
cp mexico.sqlite3 docs/
git commit -am "Actualizaci√≥n de febrero 2025"
git push

Los clientes seguir√°n funcionando porque el schema no cambia.

‚∏ª

üß± 11. Integraci√≥n con GitHub Actions (opcional)

Puedo darte un workflow autom√°tico como este:
	‚Ä¢	descarga CSVs/SQLites originales
	‚Ä¢	genera mexico.sqlite3
	‚Ä¢	sube a GitHub Pages autom√°ticamente

Dime y te lo armo completo.

‚∏ª

üéâ Listo. Tienes un instructivo completo.

Si quieres, puedo tambi√©n:
	‚Ä¢	revisar el schema de tus SQLite actuales,
	‚Ä¢	hacer un script ‚Äúuniversal‚Äù que detecta autom√°ticamente las tablas,
	‚Ä¢	crear un archivo build.sh para tu repo,
	‚Ä¢	crear el workflow de GitHub Actions,
	‚Ä¢	crear un demo en HTML/JS que use Range Requests.

¬øQuieres que generemos el workflow de Actions o el demo HTML/JS?
